#!/bin/bash

# Java Classpath Compiler and Runner with Maven support
# Compiles and runs Java projects based on .classpath or Maven pom.xml

set -e # Exit on any error

# Configuration
CLASSPATH_FILE=".classpath"
OUTPUT_DIR="build"
MAIN_CLASS=""

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
print_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
print_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
print_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Function to show usage
show_usage() {
    echo "Usage: $0 [OPTIONS] [MAIN_CLASS]"
    echo ""
    echo "OPTIONS:"
    echo "  -c, --compile-only    Compile only, don't run"
    echo "  -r, --run-only        Run only, don't compile"
    echo "  -f, --classpath FILE  Use custom classpath file (default: .classpath)"
    echo "  -o, --output DIR      Output directory for compiled classes (default: build)"
    echo "  -h, --help           Show this help message"
    echo ""
    echo "MAIN_CLASS:"
    echo "  Fully qualified class name to run (e.g., com.example.Main)"
    echo "  If not provided, will try to find main method automatically"
}

# Function to parse .classpath file (unchanged from your original script)
parse_classpath() {
    local classpath_file="$1"
    local src_paths=""
    local lib_paths=""

    if [[ -f "$classpath_file" ]]; then
        print_info "Parsing classpath file: $classpath_file"
        while IFS= read -r line; do
            if [[ $line =~ \<classpathentry\ kind=\"src\"\ path=\"([^\"]+)\" ]]; then
                local path="${BASH_REMATCH[1]}"
                if [[ -d "$path" ]]; then
                    src_paths="$src_paths:$path"
                    print_info "Found source directory: $path"
                else
                    print_warning "Source directory not found: $path"
                fi
            fi
        done <"$classpath_file"

        while IFS= read -r line; do
            if [[ $line =~ \<classpathentry\ kind=\"lib\"\ path=\"([^\"]+)\" ]]; then
                local path="${BASH_REMATCH[1]}"
                if [[ -f "$path" ]]; then
                    lib_paths="$lib_paths:$path"
                    print_info "Found library: $path"
                else
                    print_warning "Library not found: $path"
                fi
            fi
        done <"$classpath_file"

        SRC_PATHS="${src_paths#:}"
        LIB_PATHS="${lib_paths#:}"
    else
        print_info "No .classpath file found, using simple project structure"
        # Simple project structure: sources in root, libraries in libs/
        print_info "Looking for Java sources in current directory..."
        if find . -maxdepth 1 -name "*.java" -type f | head -1 >/dev/null 2>&1; then
            src_paths="."
            print_info "Found Java sources in root directory"
        else
            print_error "No Java source files found in current directory!"
            print_info "For simple projects, place .java files in the root directory"
            print_info "For complex projects, create a .classpath file"
            exit 1
        fi
        # Look for libs directory
        if [[ -d "+libs" ]]; then
            print_info "Found +libs directory, scanning for JAR files..."
            local jar_files=$(find +libs -name "*.jar" -type f 2>/dev/null)
            if [[ -n "$jar_files" ]]; then
                while IFS= read -r jar_file; do
                    lib_paths="$lib_paths:$jar_file"
                    print_info "Found library: $jar_file"
                done <<<"$jar_files"
            else
                print_info "No JAR files found in +libs directory"
            fi
        else
            print_info "No +libs directory found, proceeding without external libraries"
        fi
        # Remove leading colons
        SRC_PATHS="${src_paths#:}"
        LIB_PATHS="${lib_paths#:}"
    fi
}

# Function to copy assets (unchanged)
copy_assets() {
    print_info "Copying assets to build directory..."
    IFS=':' read -ra PATHS <<<"$SRC_PATHS"
    local assets_copied=0
    for path in "${PATHS[@]}"; do
        if [[ -d "$path" ]]; then
            # Find all non-Java files (excluding .java and .class files)
            while IFS= read -r -d '' asset_file; do
                if [[ -f "$asset_file" ]]; then
                    # Calculate relative path from source directory
                    local rel_path="${asset_file#$path/}"
                    local dest_file="$OUTPUT_DIR/$rel_path"
                    local dest_dir=$(dirname "$dest_file")
                    # Create destination directory if it doesn't exist
                    mkdir -p "$dest_dir"
                    # Copy the asset file
                    if cp "$asset_file" "$dest_file" 2>/dev/null; then
                        print_info "Copied asset: $rel_path"
                        assets_coppied=$((assets_copied + 1))
                    fi
                fi
            done < <(find "$path" -type f ! -name "*.java" ! -name "*.class" ! -path "*/build/*" ! -path "*/.*" ! -name ".*" ! -name "*.jar" -print0 2>/dev/null)
        fi
    done
    if [[ $assets_copied -gt 0 ]]; then
        print_success "Copied $assets_copied asset files"
    else
        print_info "No assets found to copy"
    fi
}

# Function to find Java files (unchanged)
find_java_files() {
    local java_files=""
    print_info "Scanning source directories for Java files..."
    IFS=':' read -ra PATHS <<<"$SRC_PATHS"
    for path in "${PATHS[@]}"; do
        if [[ -d "$path" ]]; then
            print_info "Scanning directory: $path"
            local files=$(find "$path" -name "*.java" -type f 2>/dev/null)
            if [[ -n "$files" ]]; then
                local file_count=$(echo "$files" | wc -l)
                print_info "Found $file_count Java files in $path"
                java_files="$java_files $files"
            else
                print_warning "No Java files found in $path"
            fi
        else
            print_warning "Source path does not exist: $path"
        fi
    done
    JAVA_FILES="$java_files"
}

# Function to compile Java files (unchanged)
compile_java() {
    print_info "Starting compilation..."
    if [[ -d "$OUTPUT_DIR" ]]; then
        print_info "Removing existing output directory: $OUTPUT_DIR"
        if ! rm -rf "$OUTPUT_DIR"; then
            print_error "Failed to remove output directory: $OUTPUT_DIR"
            return 1
        fi
    fi
    # Create output directory
    mkdir -p "$OUTPUT_DIR"
    # Copy assets first
    copy_assets
    # Build classpath for compilation
    local compile_classpath="$LIB_PATHS"
    if [[ -n "$compile_classpath" ]]; then
        compile_classpath="$compile_classpath:$OUTPUT_DIR"
    else
        compile_classpath="$OUTPUT_DIR"
    fi
    # Find all Java files
    find_java_files
    if [[ -z "$JAVA_FILES" ]]; then
        print_error "No Java files found in source directories!"
        exit 1
    fi
    local java_file_count=$(echo $JAVA_FILES | wc -w)
    print_info "Found $java_file_count Java files to compile"
    # Debug: Show first few Java files found
    print_info "Sample Java files found:" echo $JAVA_FILES | tr ' ' '\n' | head -5 | while read -r file; do
        if [[ -n "$file" ]]; then
            print_info " - $file"
        fi
    done
    # Compile Java files with verbose output
    print_info "Compiling with classpath: $compile_classpath"
    print_info "Running javac command..."
    compile_all_at_once "$compile_classpath"
}

# Function to compile all files at once
compile_all_at_once() {
    local compile_classpath="$1"
    # Create a temporary file to capture compilation output
    local compile_output=$(mktemp)
    local compile_errors=$(mktemp)
    # Run javac and capture both stdout and stderr
    print_info "Compiling all files in one batch..."
    if timeout 300 javac -cp "$compile_classpath" -d "$OUTPUT_DIR" $JAVA_FILES >"$compile_output" 2>"$compile_errors"; then
        print_success "Compilation completed successfully!"
        # Show compilation summary
        local class_count=$(find "$OUTPUT_DIR" -name "*.class" -type f | wc -l)
        print_info "Generated $class_count .class files"
    else
        local exit_code=$?
        if [[ $exit_code -eq 124 ]]; then
            print_error "Compilation timed out after 5 minutes!"
            print_info "Try using --batch-compile for large projects"
        else
            print_error "Compilation failed!"
        fi
        print_error "Compilation errors:"
        cat "$compile_errors"
        if [[ -s "$compile_output" ]]; then
            print_info "Compilation output:" head -20 "$compile_output"
        fi
        # Cleanup temp files
        rm -f "$compile_output" "$compile_errors"
        exit 1
    fi
    # Cleanup temp files
    rm -f "$compile_output" "$compile_errors"
}

# Function to find main class (unchanged)
find_main_class() {
    print_info "Searching for main methods..."
    local main_classes=()

    mapfile -t main_classes < <(
        find "$OUTPUT_DIR" -name "*.class" -type f |
            sed "s|^$OUTPUT_DIR/||" | sed 's|/|.|g' | sed 's|\.class$||' |
            xargs -P 8 -I {} sh -c "javap -cp '$OUTPUT_DIR' '{}' 2>/dev/null | grep -Eq '(public static )?void main(\(\)|\(java\.lang\.String\[\]\))' && echo '{}'"
    )
    if [[ ${#main_classes[@]} -eq 0 ]]; then
        print_error "No main methods found!"
        return 1
    elif [[ ${#main_classes[@]} -eq 1 ]]; then
        print_info "Found single main class: ${main_classes[0]}"
        echo "${main_classes[0]}"
        return 0
    else
        print_info "Found ${#main_classes[@]} classes with main methods"
        # Check if fzf is available
        if command -v fzf >/dev/null 2>&1; then
            print_info "Using fzf to select main class..."
            # Create a formatted list for fzf with class names and file locations
            local fzf_input=""
            for class_name in "${main_classes[@]}"; do
                local class_file=$(echo "$class_name" | sed 's|\.|/|g').class
                local source_info=""
                # Try to find the source file for additional context
                IFS=':' read -ra SRC_PATHS_ARRAY <<<"$SRC_PATHS"
                for src_path in "${SRC_PATHS_ARRAY[@]}"; do
                    local java_file="$src_path/$(echo "$class_name" | sed 's|\.|/|g').java"
                    if [[ -f "$java_file" ]]; then
                        source_info=" (from $java_file)"
                        break
                    fi
                done
                fzf_input="$fzf_input$class_name$source_info\n"
            done
            # Use fzf to select main class
            local selected=$(echo -e "$fzf_input" | fzf \
                --height=40% \
                --layout=reverse \
                --border \
                --prompt="Select main class to run: " \
                --header="Found ${#main_classes[@]} classes with main methods" \
                --preview='echo "Class: {1}" && echo "" && echo "Full name: {1}" | sed "s/\./ â†’ /g"' \
                --preview-window=up:3:wrap)
            if [[ -n "$selected" ]]; then
                # Extract just the class name (before any parentheses)
                local chosen_class=$(echo "$selected" | cut -d' ' -f1)
                print_success "Selected: $chosen_class"
                echo "$chosen_class"
                return 0
            else
                print_warning "No class selected, exiting..."
                exit 0
            fi
        fi
    fi
}

# Function to run Java app (unchanged)
run_java() {
    local main_class="$1"
    if [[ -z "$main_class" ]]; then
        print_info "No main class specified, searching automatically..."
        main_class=$(find_main_class | tail -n1)
        if [[ -z "$main_class" ]]; then
            print_error "No main class found! Please specify one manually."
            print_info "Usage: $0 com.example.YourMainClass"
            exit 1
        fi
        print_info "Found main class: $main_class"
    fi

    # Build runtime classpath
    local runtime_classpath="$OUTPUT_DIR"
    if [[ -n "$LIB_PATHS" ]]; then
        runtime_classpath="$runtime_classpath:$LIB_PATHS"
    fi
    print_info "Running: $main_class"
    print_info "Classpath: $runtime_classpath"
    echo "----------------------------------------"
    java -cp "$runtime_classpath" "$main_class"
}

# Parse command-line arguments
COMPILE_ONLY=false
RUN_ONLY=false

while (("$#")); do
    case "$1" in
    -c | --compile-only)
        COMPILE_ONLY=true
        shift
        ;;
    -r | --run-only)
        RUN_ONLY=true
        shift
        ;;
    -f | --classpath)
        CLASSPATH_FILE="$2"
        shift 2
        ;;
    -o | --output)
        OUTPUT_DIR="$2"
        shift 2
        ;;
    -h | --help)
        show_usage
        exit 0
        ;;
    *)
        MAIN_CLASS="$1"
        shift
        ;;
    esac
done

[[ "$COMPILE_ONLY" == true && "$RUN_ONLY" == true ]] && print_error "Cannot use both --compile-only and --run-only" && exit 1

print_info "Java Classpath Compiler and Runner"
print_info "=================================="

# --- Maven detection ---
if [[ -f "pom.xml" ]]; then
    print_info "Detected Maven project (pom.xml found)"
    # Determine main class
    OUTPUT_DIR="target/classes"

    [[ -z "$MAIN_CLASS" ]] && MAIN_CLASS=$(find src/examples/java -name "*.java" \
        -exec grep -l "public static void main" {} \; |
        sed 's#src/examples/java/##; s#/#.#g; s#.java$##' |
        fzf)

    [[ -z "$MAIN_CLASS" ]] && print_error "No main class found!" && exit 1

    print_info "Running Maven exec:java with main class $MAIN_CLASS"
    mvn exec:java -Dexec.mainClass="$MAIN_CLASS"
else
    # Parse classpath if not Maven
    parse_classpath "$CLASSPATH_FILE"

    # Compile if needed
    [[ "$RUN_ONLY" != true ]] && compile_java
    # Run if needed
    [[ "$COMPILE_ONLY" != true ]] && run_java "$MAIN_CLASS"
fi

print_success "Script completed successfully!"
